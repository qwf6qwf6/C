#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
int main()
{
	int a, b, c;
	a = 1;
	b = 2;
	c = 3;
	scanf("%d", &a);
	b = (a > 5 ? 6 : -6);//三目操作符，表达式1？表达式2：表达式三，判断表达式1，为真则为表达式2，假则为表达式3
	/*等价于：
	if（a>5)
		b=3
	else
		b=-3）*/
	printf("%d\n", b);
	if (!a > b)//!为反运算符，！运算式中的运算式：算式为真（返回非0），结果为假（结果为0），算式为假（返回0），结果为真（结果1）
		printf("a\n");
	if (!a)
		printf("a为假\n");//特殊用法，！a是a为假的意思，计算机非0为假，所以输入0结果为1，为假
	if (a > b && b > 0)//&&表示并且，二者同时成立为真，值得一说的是不能写成a>b>0，因为程序会从左往右识别，为a>b成立，然后同时a>b成功后返回1，1>0成立；
		printf("b\n");
	if (a > b || b < 0)//||表示或者，二者有一者成立都为真；c语言的表达式总是从左往右的，如果左边就已经使得整个成立，就不再执行右边的了（这个过程称为短路），对应&&,左边为0假，右边不用算，对于||左边为1真，右边不用算比如a>1&&a<2,如果a=0，那么判断第一个a>1时就已经失败了，整个过程不可能再成立，就不再算第二个了；a>1||a<2，输入2，因为第一个a>1已经满足了，整个过程已经成立了，就不算第二个了
		printf("c\n");
	a = 0;
	b = 1;
	c = 2;
	int i = 10;
	i = a++ && ++b && c++;
	printf("%d,%d,%d,%d\n", a, b, c, i);//因为a++是先使用再++，所以对于&&来说，左边为0，短路，不执行后面的
	a = 1;
	b = 1;
	c = 2;
	i = 10;
	i = a++ && ++b && c++;
	printf("%d,%d,%d,%d\n", a, b, c, i);//a这时候为1了，对于&&来说左边不是0了，后面继续算，
	a = 2;
	b = 1;
	c = 2;
	i = 10;
	i = a++ || ++b || c++;
	printf("%d,%d,%d,%d", a, b, c, i);//但是并且时因为左边a为非0为真，并且之后后面不算了
	return 0;
}