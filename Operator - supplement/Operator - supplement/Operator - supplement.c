#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
int main()
{
	//16进制0x，8进制0
	printf("%d\n", 15);
	printf("%d\n", 0xF);//16进制123456789ABCDEF（9后用字母）
	printf("%d\n", 017);
	//2进制转8(2^3)进制:从右往左每3位合成一次，比如1 010 101变成8进制就是1 2 5
	//2进制转16(2^4)进制:从右往左每4位合成一次，比如101 0101变成16进制就是9 9
	//整数的表达形式有原码，反码，补码三种;有符号的整数有符号位和数值位表示，第一位为符号位0+1-，后面为二进制数值表示
	//正整数的原码反码补码三种形式相同，负整数的各不相同
	//比如整数-7的二进制表达形式就是1 00000000000000000000111(整形占4个字节=32bit)1就表示负数
	//对于负整数，原码就是直接二进制表示形式，反码就是符号位不变其他按位取反（0 to 1，1 to 0），补码就是反码加1
	//比如-7的原码就是100000000000000000000111，反码就是11111111111111111111111111111000，补码就是11111111111111111111111111111001
	//在内存中存储的整数都是补码（可以将符号位和数值位统一处理），同时加法减法也可以统一处理（CPU只能算加法，比如1-1在cpu中计算位1+(-1)）,此外补码和源码转化运算方式是相同的，不需要额外的硬件电路。
	// 
	//位移操作符<<,>>（只能操作整数）（操作的是二进制表达方式）
	//不要移动负数位，这是未定义的，同时也不要超出它存储的范围
	int a = -9;
	int b = a << 1;//左移规则，左边抛弃，右边补0
	int c = a >> 1;//右移规则分为逻辑右移和算数右移;逻辑右移:右边抛弃，左边补0;算数右移:右边抛弃，左边用原有的符号位填充（由编译器规定，但是大部分采用算数右移）
	printf("b=%d\nc=%d\n", b,c);
	//9在内存中存储为
	//          |111111111111111111110111|
	//左移后  1 |111111111111111111101110|
	//右移后    |111111111111111111111011|1

	//按位操作符:按位与&按位或|按位异或^按位取反~（对二进制位进行运算）
	int q = -5;
	//a补码:11111111111111111111111111110111
	//q补码:11111111111111111111111111111011
	//按位与:取同时都是1就为1，否则为0;故为:11111111111111111111111111110011
	//按位或:与按位与相反，同时为0就为0，否则为1;故为11111111111111111111111111110111
	//按位异或：相同为0，相异为1;故为00000000000000000000000000001100
	//按位取反：1变0，0变1
	int w = a & q; int f = a | q; int m = a ^ q; int n = ~q;
	printf("w=%d\nf=%d\nm=%d\nn=%d\n",w,f,m,n);
	//逗号表达式：会从左到右依次计算，然后取最右边的结果
	int x = (a>b,b+1,a=b,b=a+1);
	printf("x=%d,a=%d\n", x,b);
	int y = (a=b+1,b + 1);//逗号表达式中的如果是a=b+1会实际变化，但是如果是b+1就不会
	printf("a=%d\n", b);

	//操作符的优先级和结合性
	
	//优先级相同，默认结合性是从左到右的，但是可以用（）来改变它的结合性和优先级
	return 0;


}